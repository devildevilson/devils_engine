#ifndef DEVILS_ENGINE_PAINTER_WORKFLOW_H
#define DEVILS_ENGINE_PAINTER_WORKFLOW_H

#include <cstddef>
#include <cstdint>
#include <tuple>

struct semaphore;
struct submitinfo;
struct queue;

namespace devils_engine {
namespace painter {
class workflow {
public:
  workflow();

  // тут мы зададим  входные данные, как? нет данные тут нам задавать ни к чему
  // тут мы зададим выходные данные, как?

  // получаться у нас так или иначе будет VkSubmitInfo

  // я подозреваю что все входы и выходы мне нужно будет задать разделив каждый на типы
  // например у меня как минимум задаются на вход такие вещи как:
  // 1. просто буффер на чтение через дескриптор
  // 2. просто картинка на чтение через дескриптор
  // 3. буфер вершин + буфер индексов + буфер инстансов (и даже несколько)
  // 4. входные аттачменты (редко)
  // на выход:
  // 1. просто буфер на запись через дескриптор
  // 2. просто картинка на запись через дескриптор
  // 3. выходные аттачменты (фреймбуфер)
  // часть из этого связана с материалами, часть из этого задается так

  virtual void add_dependencies(std::initializer_list<workflow*> ws) = 0;
  virtual std::tuple<semaphore, uint32_t> get_barrier() = 0;
  virtual size_t setup_submits(submitinfo* arr, const size_t max_size) = 0; // большинство будет возвращать 1
  // workflow должен быть самодостаточным, возможно процессы можно будет даже запускать параллельно
  // по идее в каждом таком запуске будут уже заданы командные буферы и их нужно будет только просто правильно заполнить
  // возможно в каком то воркфлоу даже и этого делать не придется
  // как быть с буферизацией? вообще довольно просто: нам достаточно гарантировать что за время смены кадра 
  // мы успеем вычислить все задачи воркфлоу... даже не так за время кадра мы успеем вычислить все команды
  // в командном буфере, то есть у нас есть текущий кадр который показывается человечку, у нас есть 
  // кадр который вычисляется в текущий момент в кью и мы можем подождать просто этот кадр и начать вычислять все еще раз
  // это по идее как раз мэилбокс, тупо на фоне почти без перерыва вычисляем что можем + примерно так же будет работать immediate
  // есть еще фифо в котором нам необязательно торопиться 
  // и нам в общем то еще нужно где то дополнительно держать парочку фенсов (к каждой картинке -1?)
  // опять уточнение: мы выносим ожидание картинки вообще в отдельный сабмит, 
  // фенс оттуда сигнализирует что мы можем дропнуть данные в текущем гбуфере и начать вычислять все заново
  // 
  virtual void process() = 0;
protected:
  // хранилище для семафор, пока не понимаю как адекватно сделать
};

class executor {
public:
  void execute(queue q) = 0;
  bool execution_status() const = 0; // предположительно может быть только в двух состояниях (он не понимает всей картины в целом)
};	

//  желательно чтобы эти классы были копируемы
class sequential_executor : public executor {
public:
  // на вход тут может быть подано либо sequential_executor либо parallel_executor либо какой то конкретный воркфлоу
};
class parallel_executor : public executor {};

// этому должен сопутствовать граф вычислений
class execution_graph {
public:
  template <typename... T>
  execution_graph(T&&... ts);


};

// для последоательного исполнения достаточно указать один фенс, а вот для параллельного так не получится
// да еще бы желательно забатчить все вызовы сиквенсов типа: sequence(sequence(), sequence(sequence(), sequence()), sequence())
// чтобы все это дело попало в один сиквенс
// блин короче надеюсь мне кто нибудь все таки ответит
// наверное это исключительно удобный интерфейс для workflow::add_dependencies
template <typename... T>
auto sequence(T&&... ts) -> sequential_executor;
template <typename... T>
auto parallel(T&&... ts) -> parallel_executor;

const auto p = parallel(sequence(parallel()), sequence());

class material {
public:
  material();

  // материал представляет из себя просто пайплайн + набор текстурок
  // и мы прежде чем что то рисовать просто должны применить материал
  // таким образом необязательно жестко привязываться к юниту 
  // в плане того как его рисовать, нужно просто указать материал
  // перед тем как вызвать у меша функцию нарисовать
};
}
}

#endif